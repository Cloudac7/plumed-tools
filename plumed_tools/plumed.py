from typing import Optional, Union
from pydantic import BaseModel

from plumed_tools.actions.analysis import PRINT
from plumed_tools.actions.bias import (
    LOWER_WALLS, UPPER_WALLS, OPES_METAD, OPES_METAD_EXPLORE, METAD
)
from plumed_tools.actions.colvar import (
    DISTANCE, ANGLE, TORSION, COORDINATION
)
from plumed_tools.actions.generic import UNITS
from plumed_tools.actions.group import GROUP, COM, Labeled
from ase.atoms import Atoms


class ACTIONS(BaseModel):
    distance: Optional[list[Union[DISTANCE, None]]] = []
    angle: Optional[list[Optional[ANGLE]]] = []
    torsion: Optional[list[Optional[TORSION]]] = []
    coordination: Optional[list[Optional[COORDINATION]]] = []
    com: Optional[list[Optional[COM]]] = []
    upper_walls: Optional[list[Optional[UPPER_WALLS]]] = []
    lower_walls: Optional[list[Optional[LOWER_WALLS]]] = []

    metad: Optional[Optional[METAD]] = None
    opes_metad: Optional[Optional[OPES_METAD]] = None
    opes_metad_explore: Optional[Optional[OPES_METAD_EXPLORE]] = None

    print: Optional[list[Optional[PRINT]]] = []


class PlumedInput(BaseModel):
    UNITS: Optional[UNITS]
    GROUPS: Optional[list[Union[GROUP, Labeled]]]
    ACTIONS: Optional[ACTIONS]


class PlumedBuilder:

    def __init__(self, init_structure: Atoms, units: Optional[dict[str, str]] = None):
        self.init_structure = init_structure
        if units:
            self.units = UNITS(**units)
        else:
            self.units = UNITS()
        self.groups = []
        self.actions = ACTIONS()
        self.plumed_input = None

    def build(self):
        self.plumed_input = PlumedInput(
            UNITS=self.units,
            GROUPS=self.groups,
            ACTIONS=self.actions
        )
        return self.plumed_input

    def _convert_atoms(self, ATOMS: list[Union[int, str, Labeled]]):
        for i, atom in enumerate(ATOMS):
            if isinstance(atom, int):
                # Convert negative indices to positive
                ATOMS[i] = atom % len(self.init_structure)
            elif isinstance(atom, str):
                # Find the atom with the given label
                if self.groups:
                    for vatom in self.groups:
                        if vatom.LABEL == atom:
                            break
                else:
                    raise ValueError(f"VATOM with LABEL {atom} not found")
            elif isinstance(atom, Labeled):
                pass
            else:
                raise ValueError("ATOMS must be a list of integers or strings")
        return ATOMS

    def add_com(self, LABEL, ATOMS: list[Union[int, str, Labeled]], **kwargs):
        ATOMS = self._convert_atoms(ATOMS)
        print(ATOMS)
        com = COM(LABEL=LABEL, ATOMS=ATOMS, **kwargs)
        self.groups.append(com)
        return com

    def add_group(self, LABEL, ATOMS: list[Union[int, str, Labeled]], **kwargs):
        ATOMS = self._convert_atoms(ATOMS)
        group = GROUP(LABEL=LABEL, ATOMS=ATOMS, **kwargs)
        self.groups.append(group)
        return group

    def add_distance(self, **kwargs):
        distance = DISTANCE(**kwargs)
        self.actions.distance.append(distance)
        return distance

    def add_angle(self, **kwargs):
        angle = ANGLE(**kwargs)
        self.actions.angle.append(angle)
        return angle

    def add_torsion(self, **kwargs):
        torsion = TORSION(**kwargs)
        self.actions.torsion.append(torsion)
        return torsion

    def add_coordination(self, **kwargs):
        coordination = COORDINATION(**kwargs)
        self.actions.coordination.append(coordination)
        return coordination

    def add_upper_walls(self, **kwargs):
        upper_walls = UPPER_WALLS(**kwargs)
        self.actions.upper_walls.append(upper_walls)
        return upper_walls

    def add_lower_walls(self, **kwargs):
        lower_walls = LOWER_WALLS(**kwargs)
        self.actions.lower_walls.append(lower_walls)
        return lower_walls

    def add_metad(self, **kwargs):
        metad = METAD(**kwargs)
        self.actions.metad = metad
        return metad

    def add_opes_metad(self, **kwargs):
        opes_metad = OPES_METAD(**kwargs)
        self.actions.opes_metad = opes_metad
        return opes_metad

    def add_opes_metad_explore(self, **kwargs):
        opes_metad_explore = OPES_METAD_EXPLORE(**kwargs)
        self.actions.opes_metad_explore = opes_metad_explore
        return opes_metad_explore

    def add_print(self, **kwargs):
        print_ = PRINT(**kwargs)
        self.actions.print.append(print_)
        return print_


class PlumedFile:

    def __init__(self, plumed_input: PlumedInput):
        self.plumed_input = plumed_input
        self.lines = []

    def generate(self):
        lines = ["# PLUMED input file generated by plumed_tools\n"]
        lines += self.generate_units()
        lines += self.generate_labeled()
        lines += self.generate_actions()

        self.lines = lines
        return lines

    def dump(self, fileobj) -> None:
        for line in self.lines:
            fileobj.write(line)

    def generate_units(self):
        lines = ["# Define Units\n"]
        lines += [f"UNITS " +
                  " ".join([f'{k}={v}' for k, v in self.plumed_input.UNITS.model_dump(
                      exclude_unset=True,
                      exclude_defaults=True
                  ).items()]) + "\n"]
        return lines

    def generate_labeled(self):
        lines = ["# Define Groups\n"]
        for group in self.plumed_input.GROUPS:
            if type(group) == COM:
                line = self.generate_com(group, lines)
            elif type(group) == GROUP:
                line = self.generate_groups(group, lines)
            else:
                raise ValueError(f"Group type {type(group)} not recognized")
            lines.append(line + "\n")
        return lines

    def _dump_atoms(self, atoms: Union[list, dict]):
        line = ""
        if isinstance(atoms, dict):
            if "LABEL" in atoms:
                line += f"{atoms['LABEL']}"
            else:
                line += self._dump_atoms(atoms["ATOMS"])
            return line
        for i, atom in enumerate(atoms):
            if i > 0:
                line += ","
            if isinstance(atom, Labeled):
                line += f"{atom.LABEL}"
            elif isinstance(atom, str):
                line += f"{atom}"
            else:  # atom is an integer
                line += f"{atom + 1}"
        return line

    def generate_com(self, com, lines):
        if com.LABEL is None:
            com.LABEL = f"com_{len(lines)}"
        line = f"COM LABEL={com.LABEL}"
        line += " ATOMS=" + self._dump_atoms(com.ATOMS)
        for key, value in com.model_dump(
            exclude_defaults=True
        ).items():
            if key not in ["ATOMS", "LABEL"]:
                line += f" {key}={value}"
        return line

    def generate_groups(self, group, lines):
        if group.LABEL is None:
            group.LABEL = f"group_{len(lines)}"
        line = f"GROUPS LABEL={group.LABEL}"
        line += " ATOMS=" + self._dump_atoms(group.ATOMS)
        if group.REMOVE is not None:
            line += " REMOVE=" + self._dump_atoms(group.REMOVE)
        for key, value in group.model_dump(
            exclude_defaults=True
        ).items():
            if key not in ["ATOMS", "LABEL", "REMOVE"]:
                if isinstance(value, list):
                    value = " ".join([str(v) for v in value])
                elif isinstance(value, bool):
                    value = "ON" if value else "OFF"
                elif value is None:
                    continue
                line += f" {key}={value}"
        return line

    def generate_actions(self):
        lines = ["# Define Actions\n"]
        for action_type, action in self.plumed_input.ACTIONS.model_dump(
            exclude_defaults=True
        ).items():
            if isinstance(action, list):
                for act in action:
                    if act.get("LABEL") is None:
                        act["LABEL"] = f"action_{len(lines)}"
                    line = f"{action_type.upper()} LABEL={act['LABEL']}"
                    line += self.dump_action_parameters(act)
                    lines.append(line)
            else: # action is a single action
                if action.get("LABEL") is None:
                    action["LABEL"] = f"action_{len(lines)}"
                line = f"{action_type.upper()} LABEL={action['LABEL']}"
                line += self.dump_action_parameters(action)
                line += "\n"
                lines.append(line)
        return lines

    def dump_action_parameters(self, parameters):
        line = ""
        for key, value in parameters.items():
            print(key, value)
            if key == "ATOMS":
                line += " ATOMS=" + self._dump_atoms(value)
            elif key not in ["ATOMS", "LABEL"]:
                line += f" {key}={self.dump_action_options(value)}"
        return line

    def dump_action_options(self, value):
        parameters = ""
        if isinstance(value, list):
            parameters += " ".join([str(v) for v in value])
        else:
            parameters += str(value)
        return parameters
